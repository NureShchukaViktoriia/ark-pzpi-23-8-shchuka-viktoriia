Харківський національний університет радіоелектроніки
Факультет комп’ютерних наук
Катедра програмної інженерії 



ЗВІТ
до практичного завдання № 2
з дисципліни «Аналіз та рефакторинг коду»
на тему: «Методи рефакторингу коду програмного забезпечення» 



Виконала:	
ст. гр. ПЗПІ-23-8 	
Щука Вікторія 	
 
Перевірив:
ст. викладач катедри ПІ
Сокорчук Ігор Петрович




Харків 2025

1 ІСТОРІЯ ЗМІН
№
Дата
Версія звіту
Опис змін та виправлень
1
17.12.2025
0.1
Створено розділ «Завдання»
2
18.12.2025
0.2
Створено розділ «Опис Виконаної роботи»
3
20.12.2025
0.3
Створено додаток Б



2 ЗАВДАННЯ
     Завданням даної роботи є опанування практичних навичок рефакторингу програмного коду на основі методології Мартіна Фаулера для покращення його внутрішньої структури та якості.
     Для досягнення поставленої мети необхідно виконати такі завдання:
* обрати три методи рефакторингу з книги Мартіна Фаулера «Refactoring: Improving the Design of Existing Code» (Encapsulate Field, Move Field);
* підібрати фрагменти власного коду, які потребують вдосконалення відповідно до обраних методів;
* надати детальний опис проблеми для кожного випадку, обґрунтувавши, чому поточна реалізація ускладнює розуміння, супровід або розширення програми;
* продемонструвати процес трансформації, навівши порівняльні фрагменти вихідного коду (до рефакторингу) та оновленого коду (після застосування методу);
* проаналізувати результати рефакторингу, сформулювавши переваги використаного підходу, такі як підвищення читабельності, спрощення тестування або усунення дублювання логіки.


3 ОПИС ВИКОНАНОЇ РОБОТИ
     3.1 Вступ
     Почнемо з того, що таке рефакторинг (refactoring). Це процедура, яка передбачає переробку вихідного коду програми так, щоб він став більш простим та зрозумілим. При цьому нові функції не додаються, а старі зберігаються.
     Справа в тому, що розробники у процесі своєї роботи, як правило, поспішають, додають нові функції або виправляють існуючі баги. Все це призводить до того, що код стає безладним і незрозумілим. А щоб він мав більш адекватний вигляд, рекомендується проводити рефакторинг.
     Загалом ця процедура спрямована:
* збереження архітектури проекту, без втрати структурованості;
* на спрощення життя розробників, роблячи код прозорим та зрозумілим для всіх членів команди;
* на прискорення процесу пошуку помилок.
     Також варто розуміти, що мова програмування вдосконалюється: з’являються нові функції, бібліотеки, тобто те, що робить код простішим і зрозумілішим. Навіть ідеальна програма, написана рік/два тому, згодом потребує нового рефакторингу. Завдання процесу – оновити ділянки застарілого коду.
     Іншими словами можна сказати, що refactoring – упорядкування робочого місця. 
     3.2 Приклад коду до рефакторингу:
     Приклад коду проєкта Enterprise User Management System до рефакторингу наведено в додатку В.1. 
     Початковий контекст проєкту:
     Є базовий клас User, від якого наслідуються: AdminUser, CustomerUser. З часом клас User «розрісся» і містить поля, які:
* використовуються не всіма нащадками
* доступні напряму (порушення інкапсуляції)
* логічно належать іншим сутностям
Проблеми:
* порушена інкапсуляція — всі поля public;
* User перевантажений даними, які не стосуються всіх користувачів;
* поля address і phone логічно не належать User;
* складно підтримувати та розширювати систему.
     3.3 Основні методи рефакторингу
     3.3.1 Метод «Move Field» (переміщення поля)
     Move Field Refactoring — це рефакторинг, який полягає у переміщенні поля (змінної класу) з одного класу в інший, де воно логічно повинно знаходитись.
     Коли застосовують:
* поле частіше використовується іншим класом, ніж тим, у якому оголошене;
* поле описує стан іншого об’єкта, а не поточного;
* клас містить дані, які не відповідають його відповідальності.
     Мета застосування: покращити інкапсуляцію, зменшити зв’язаність класів, дотриматися принципу Single Responsibility.
     Кроки рефакторингу:
* визначити клас, якому поле логічно належить;
* перемістити поле в новий клас;
* оновити всі звернення до поля;
* за потреби додати гетери/сетери;
* перевірити працездатність (тести).
Приклад (до рефакторингу):
1  class Order {
2      Customer customer;
3      String customerAddress;
4  }
Приклад після Move Field:
1  class Customer {
2      String address;
3  }
4
5  class Order {
6      Customer customer;
7  }

     Приклад коду проєкта Enterprise User Management System після рефакторигну Move Field наведено в додатку В.2.
Проблема до рефакторингу: поля address та phone знаходилися у класі User, хоча:
* не є частиною логіки облікового запису;
* належать до персонального профілю користувача;
* використовуються незалежно від типу користувача.
Таким чином, клас User поєднував декілька різних відповідальностей.
     Реалізація: було створено окремий клас UserProfile, до якого перенесено поля: address та phone. Клас User тепер містить лише посилання на UserProfile.
     Результат після застосування Move Field:
* відповідальності між класами чітко розмежовані;
* покращено читабельність архітектури;
* зменшено зв’язаність класів;
* реалізовано принцип Single Responsibility Principle.
     3.3.2 Метод «Encapsulate Field» (інкапсуляція поля)
     Encapsulate Field Refactoring (інкапсуляція поля) — це рефакторинг, під час якого прямий доступ до поля замінюється доступом через методи (getter і setter).
     Коли застосовують:
* поле є public або доступне напряму ззовні;
* потрібно контролювати зміну значення поля;
* планується додати валідацію, логіку або логування;
* порушується принцип інкапсуляції.
     Мета: захистити внутрішній стан об’єкта, зменшити залежність зовнішнього коду, полегшити подальші зміни реалізації.
     Кроки рефакторингу:
* змінити модифікатор доступу поля на private;
* створити getter і setter;
* замінити всі прямі звернення до поля викликами методів;
* за потреби додати перевірки або додаткову логіку;
* запустити тести.
Приклад (до рефакторингу):
1  class Person {
2    public String name;
3  }
Приклад після Encapsulate Field:
1  class Person {
2    private String name;
3
4    public String getName() {
5      return name;
6    }
7    public void setName(String arg) {
8      name = arg;
9    }
10 }

     Приклад коду проєкта Enterprise User Management System після рефакторигну Encapsulate Field наведено в додатку В.3.
     Проблема до рефакторингу: у вихідному коді поля класу User були оголошені як public, що дозволяло:
* змінювати значення полів без будь-якого контролю;
* порушувати цілісність об’єкта;
* створювати приховані залежності між класами.
Це є прямим порушенням принципу інкапсуляції — одного з базових принципів ООП.
     Для реалізації було виконано такі дії:
* всі поля класу зроблено private;
* доступ до них здійснюється через публічні або захищені методи;
* частина setter-методів обмежена рівнем доступу (protected) для контролю змін у нащадках.
     Результат після застосування Encapsulate Field:
* внутрішній стан об’єкта захищений від неконтрольованих змін;
* з’явилася можливість додавати валідацію, логування або обмеження;
* код став більш стабільним та безпечним.
     3.3.3 Метод «Push Down Field» (cпуск поля)
     Push Down Field (cпуск поля) — це рефакторинг, за якого поле переноситься з батьківського (superclass) класу до одного або кількох дочірніх (subclass) класів, де воно реально використовується.
     Коли застосовують:
* поле в базовому класі не використовується всіма нащадками;
* лише окремі підкласи потребують цього поля;
* базовий клас стає перевантаженим зайвими даними.
     Мета: спрощення базового класу, чіткіша ієрархія успадкування, дотримання принципу Single Responsibility.
     Кроки рефакторингу:
* визначити підкласи, які реально використовують поле;
* видалити поле з батьківського класу;
* додати поле в відповідні дочірні класи;
* оновити всі звернення до поля;
* перевірити код (тести).
Приклад (до рефакторингу):
1  class Employee {
2      String bonus;
3  }
4
5  class Manager extends Employee {
6  }
7  
8  class Developer extends Employee {
9  }
     Приклад після Push Down Field:
1  class Employee {
2  }
3
4  class Manager extends Employee {
5      String bonus;
6  }
7 
8  class Developer extends Employee {
9  }

     Приклад коду проєкта Enterprise User Management System після рефакторигну Push Down Field наведено в додатку В.4.
Проблема до рефакторингу: у базовому класі User містилися поля:
* loyaltyPoints, що використовується лише класом CustomerUser;
* adminRole, що використовується лише класом AdminUser.
Це призводило до наявності “зайвих” даних у об’єктах; ускладнення розуміння ієрархії; порушення логіки наслідування.
     Реалізація: було виконано:
* видалення специфічних полів з базового класу User;
* додавання поля loyaltyPoints до класу CustomerUser;
* додавання поля adminRole до класу AdminUser;
* оголошення класу User як абстрактного.
     Результат: після застосування Push Down Field:
* кожен клас містить лише релевантні дані;
* ієрархія стала логічно обґрунтованою;
* зменшено надмірність та ризик помилок;
* полегшено подальше розширення системи.

4 ВИСНОВКИ
     У ході виконання роботи було розглянуто та практично застосовано методи рефакторингу Encapsulate Field, Move Field та Push Down Field на прикладі об’єктно-орієнтованого програмного проєкту. Застосування цих методів дозволило усунути недоліки початкової архітектури, зокрема порушення інкапсуляції, надмірну перевантаженість базових класів та нераціональне використання механізму наслідування.
     У результаті рефакторингу було досягнуто чіткого розмежування відповідальностей між класами, зменшено зв’язаність компонентів та підвищено логічну узгодженість ієрархії. Код став більш зрозумілим, структурованим і готовим до подальшого розширення без значних змін існуючої логіки.
     Таким чином, виконана робота підтверджує, що систематичне застосування методів рефакторингу є ефективним засобом підвищення якості програмного забезпечення, зниження технічного боргу та забезпечення довготривалої підтримуваності великих програмних систем.


5 ВИКОРИСТАНІ ДЖЕРЕЛА
     1 Інкапсуляція поля. refactoring.guru. URL: https://refactoring.guru/uk/encapsulate-field (дата звернення: 18.12.2025).
     2 Переміщення поля. refactoring.guru. URL: https://refactoring.guru/uk/move-field (дата звернення: 18.12.2025).
     3 Спуск поля. refactoring.guru. URL: https://refactoring.guru/uk/push-down-field (дата звернення: 19.12.2025).


ДОДАТОК А
Відеозапис
Відеозапис доповіді: https://youtu.be/nGOwXjEXPxY
     Хронологічний опис відеозапису:
00:00 - Вступ. 
01:38 - Приклад коду до рефакторингу. 
02:24 - Метод «Move Field». 
03:31 - Приклад програмного коду після рефакторигну Move Field. 
04:40 - Метод «Encapsulate Field». 
05:45 - Приклад програмного коду після рефакторигну Encapsulate Field. 
07:05 - Метод «Push Down Field». 
08:15 - Приклад програмного коду після рефакторигну Push Down Field. 
09:46 - Висновки.


ДОДАТОК Б
Слайди презентації

Рисунок Б.1 – Титульний слайд


Рисунок Б.2 – Вступ


Рисунок Б.3 – Приклад коду до рефакторингу


Рисунок Б.4 – Метод «Move Field»

Рисунок Б.5 – Приклад програмного коду після рефакторигну Move Field


Рисунок Б.6 – Метод «Encapsulate Field»

Рисунок Б.7 – Приклад програмного коду після рефакторигну Encapsulate Field


Рисунок Б.8 – Метод «Push Down Field»

Рисунок Б.9 – Приклад програмного коду після рефакторигну Push Down Field

Рисунок Б.10 – Висновки

Рисунок Б.11 – Джерела


ДОДАТОК В
Програмний код
     В.1 Приклад оформлення програмного коду проєкта Enterprise User Management System до рефакторингу.
     GitHub репозиторій: https://github.com/NureShchukaViktoriia/ark-pzpi-23-8-shchuka-viktoriia/blob/main/Pract2/Move%20Field/before
User.java
1  public class User {
2      public String name;
3      public String email;
4
5      // Використовується лише CustomerUser
6      public int loyaltyPoints;
7
8      // Використовується лише AdminUser
9      public String adminRole;
10
11     // Дані профілю
12     public String address;
13     public String phone;
14 }

CustomerUser.java
1  public class CustomerUser extends User {
2      public void addPoints(int points) {
3          loyaltyPoints += points;
4      }
5  }

AdminUser.java
1  public class AdminUser extends User {
2      public boolean canDeleteUsers() {
3          return adminRole.equals("SUPER_ADMIN");
4      }
5  }

     В.2 Приклад оформлення програмного коду проєкта Enterprise User Management System після рефакторигну Move Field.
     GitHub репозиторій: https://github.com/NureShchukaViktoriia/ark-pzpi-23-8-shchuka-viktoriia/blob/main/Pract2/Move%20Field/after
 1 public class UserProfile {
 2     private String address;
 3     private String phone;
 4 
 5     public UserProfile(String address, String phone) {
 6         this.address = address;
 7         this.phone = phone;
 8     }
 9 
10     public String getAddress() {
11         return address;
12     }
13 
14     public String getPhone() {
15         return phone;
16     }
17 }

 1 public class User {
 2     private String name;
 3     private String email;
 4     private UserProfile profile;
 5 
 6     public User(String name, String email, UserProfile profile) {
 7         this.name = name;
 8         this.email = email;
 9         this.profile = profile;
10     }
11 
12     public UserProfile getProfile() {
13         return profile;
14     }
15 }

     В.3 Приклад оформлення програмного коду проєкта Enterprise User Management System після рефакторигну Encapsulate Field.
     GitHub репозиторій: https://github.com/NureShchukaViktoriia/ark-pzpi-23-8-shchuka-viktoriia/blob/main/Pract2/Encapsulate%20Field/after.java
 1 public class User {
 2     private String name;
 3     private String email;
 4     private int loyaltyPoints;
 5     private String adminRole;
 6     private String address;
 7     private String phone;
 8 
 9     public String getName() {
10         return name;
11     }
12 
13     public String getEmail() {
14         return email;
15     }
16 
17     public int getLoyaltyPoints() {
18         return loyaltyPoints;
19     }
20 
21     protected void setLoyaltyPoints(int loyaltyPoints) {
22         this.loyaltyPoints = loyaltyPoints;
23     }
24 
25     protected String getAdminRole() {
26         return adminRole;
27     }
28 }
     
     В.4 Приклад оформлення програмного коду проєкта Enterprise User Management System після рефакторигну Push Down Field.
     GitHub репозиторій: https://github.com/NureShchukaViktoriia/ark-pzpi-23-8-shchuka-viktoriia/blob/main/Pract2/Push%20Down%20Field/after.java
 1 public abstract class User {
 2     private String name;
 3     private String email;
 4     private UserProfile profile;
 5 
 6     public User(String name, String email, UserProfile profile) {
 7         this.name = name;
 8         this.email = email;
 9         this.profile = profile;
10     }
11 }

 1 public class CustomerUser extends User {
 2     private int loyaltyPoints;
 3 
 4     public CustomerUser(String name, String email, UserProfile profile) {
 5         super(name, email, profile);
 6     }
 7 
 8     public void addPoints(int points) {
 9         loyaltyPoints += points;
10     }
11 }

 1 public class AdminUser extends User {
 2     private String adminRole;
 3 
 4     public AdminUser(String name, String email, UserProfile profile, String adminRole) {
 5         super(name, email, profile);
 6         this.adminRole = adminRole;
 7     }
 8 
 9     public boolean canDeleteUsers() {
10         return "SUPER_ADMIN".equals(adminRole);
11     }
12 }

